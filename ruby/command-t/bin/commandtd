#!/usr/bin/env ruby

ERR_CHANNEL = STDERR.dup
OUT_CHANNEL = STDOUT.dup

STDERR.reopen('/dev/null', 'w')
STDOUT.reopen('/dev/null', 'w')

require 'ostruct'

OPTIONS = OpenStruct.new

def log(msg)
  if OPTIONS.logfile
    File.open(OPTIONS.logfile, 'a') { |f| f.puts "#{Time.now}: #{msg}"}
  end
end

require 'json'
require 'optparse'

begin
  OptionParser.new do |opts|
    opts.on('--vim-pid=PID') # Ignore: included only to make `ps` output more useful.
    opts.on('--logfile=NAME') do |logfile|
      OPTIONS.logfile = logfile
    end
  end.parse!
rescue => e
  log e
end

begin
  require 'command-t'
  require 'command-t/ext'
rescue LoadError => e
  load_path_modified = false
  [
    File.expand_path('../ext', File.dirname(__FILE__)),
    File.expand_path('../lib', File.dirname(__FILE__))
  ].each do |path|
    if !$LOAD_PATH.include?(path)
      $LOAD_PATH << path
      load_path_modified = true
    end
  end
  retry if load_path_modified

  # TODO: show error here instructing to run install script
  log e
end

log 'booted'

while true
  log 'loop'
  line = STDIN.readline.chomp
  begin
    input = JSON[line]
  rescue => e
    log "read: #{e} reading line: #{line.inspect}"
    next
  end
  log "read: #{input.inspect}"
  OUT_CHANNEL.puts input.to_json
  OUT_CHANNEL.flush
  log "wrote: #{input.to_json.inspect}"
end
